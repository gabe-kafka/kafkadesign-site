<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Structural Analysis - Kafka Design</title>
  <link rel="stylesheet" href="src/reset.css">
  <link rel="stylesheet" href="src/index.css">
  <link rel="stylesheet" href="css/styles.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/handsontable@latest/dist/handsontable.full.min.css">
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/handsontable@latest/dist/handsontable.full.min.js"></script>
  <style>
    * {
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Consolas', monospace; /* Matches styles.css */
      background: #1b1b1b; /* Dark background */
      margin: 0;
      padding: 20px;
      min-height: 100vh;
      color: #e0e0e0; /* Light gray text */
    }
    
    .container {
      max-width: 1200px;
      margin: 0 auto;
      background: #252525; /* Slightly lighter dark */
      border-radius: 4px; /* Minimal for terminal look */
      box-shadow: 0 2px 10px rgba(0,0,0,0.5);
      overflow: hidden;
    }
    
    .header {
      background: #1e1e1e; /* Darker background */
      color: #ecf0f1;
      padding: 20px;
      text-align: center;
    }
    
    .header h1 {
      margin: 0;
      font-size: 1.8em;
      font-weight: normal; /* Monospace Web style */
    }
    
    .header p {
      margin: 8px 0 0 0;
      opacity: 0.8;
      font-size: 1em;
    }
    
    .content {
      padding: 20px;
    }
    
    .input-section {
      margin-bottom: 15px;
      display: flex;
      gap: 15px;
      align-items: flex-end;
      flex-wrap: wrap;
    }
    
    .input-group {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    
    .input-group label {
      font-weight: normal;
      color: #e0e0e0;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .input-group input {
      width: 120px;
      padding: 6px 8px;
      border: 1px solid #333;
      border-radius: 2px;
      font-size: 12px;
      background: #2a2a2a;
      color: #e0e0e0;
      font-family: 'Consolas', monospace;
      transition: border-color 0.3s;
    }
    
    .input-group input:focus {
      outline: none;
      border-color: #00ff9f;
      box-shadow: 0 0 0 2px rgba(0, 255, 159, 0.2);
    }

    .input-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 15px;
      margin-bottom: 15px;
    }

    @media (max-width: 1000px) {
      .input-grid {
        grid-template-columns: 1fr;
      }
    }
    
    .spreadsheet-container {
      margin: 0;
      border-radius: 3px;
      overflow: hidden;
      box-shadow: 0 1px 5px rgba(0,0,0,0.3);
      background: #252525;
    }
    
    .spreadsheet-title {
      background: #2a2a2a;
      color: #00ff9f;
      padding: 6px 10px;
      margin: 0;
      font-size: 11px;
      font-weight: normal;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .table-container {
      overflow-x: auto;
      overflow-y: auto;
      max-height: 200px;
      background: #252525;
    }
    
    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 12px;
      font-family: 'Consolas', monospace;
    }
    
    th {
      background: #2a2a2a;
      padding: 6px 8px;
      text-align: left;
      font-weight: normal;
      color: #e0e0e0;
      border-bottom: 1px solid #333;
      font-size: 12px;
      white-space: nowrap;
    }
    
    td {
      padding: 4px 6px;
      border-bottom: 1px solid #333;
      vertical-align: middle;
      color: #e0e0e0;
    }
    
    tr:hover {
      background-color: #333333; /* Matches styles.css */
    }
    
    .table-input {
      width: 100%;
      padding: 4px 6px;
      border: 1px solid #333;
      border-radius: 2px;
      font-size: 12px;
      background: #2a2a2a;
      color: #e0e0e0;
      font-family: 'Consolas', monospace;
      transition: border-color 0.3s;
      min-width: 0;
    }
    
    .table-input:focus {
      outline: none;
      border-color: #00ff9f;
      box-shadow: 0 0 0 2px rgba(0, 255, 159, 0.2);
    }
    
    .btn {
      padding: 8px 12px;
      border: none;
      border-radius: 3px;
      cursor: pointer;
      font-size: 13px;
      font-weight: normal;
      font-family: 'Consolas', monospace;
      transition: all 0.3s;
    }
    
    .btn-add {
      background: #00ff9f; /* Green accent */
      color: #1e1e1e;
      margin: 15px 0;
      padding: 10px 20px;
      font-size: 14px;
    }
    
    .btn-add:hover {
      background: #00cc7f;
      transform: translateY(-1px);
    }
    
    .btn-remove {
      background: #ff5555; /* Red for remove */
      color: #e0e0e0;
      padding: 4px 8px;
      font-size: 11px;
    }
    
    .btn-remove:hover {
      background: #cc4444;
    }

    .btn-copy {
      background: #5555ff;
      color: #e0e0e0;
      padding: 4px 8px;
      font-size: 11px;
      margin-right: 5px;
    }

    .btn-copy:hover {
      background: #4444cc;
    }

    .btn-paste {
      background: #55ff55;
      color: #1e1e1e;
      padding: 4px 8px;
      font-size: 11px;
    }

    .btn-paste:hover {
      background: #44cc44;
    }

    .table-actions {
      display: flex;
      gap: 6px;
      padding: 6px 10px;
      background: #2a2a2a;
      border-bottom: 1px solid #333;
      align-items: center;
    }

    .table-actions button {
      font-size: 10px;
      padding: 4px 8px;
    }
    
    .btn-analyze {
      background: #00ff9f;
      color: #1e1e1e;
      padding: 8px 20px;
      font-size: 12px;
      font-weight: normal;
      border: none;
      border-radius: 3px;
      cursor: pointer;
      transition: all 0.3s;
      box-shadow: 0 2px 5px rgba(0, 255, 159, 0.3);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .btn-analyze:hover {
      background: #00cc7f;
      transform: translateY(-1px);
      box-shadow: 0 3px 8px rgba(0, 255, 159, 0.4);
    }
    
    .results {
      margin-top: 15px;
      padding: 12px;
      background: #2a2a2a;
      border-radius: 3px;
      box-shadow: inset 0 1px 5px rgba(0,0,0,0.3);
    }
    
    .results h3 {
      color: #ecf0f1;
      margin-top: 0;
      margin-bottom: 10px;
      font-size: 11px;
      font-weight: normal;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: #00ff9f;
    }
    
    .beam-diagram {
      margin: 10px 0;
      font-family: 'Consolas', monospace;
      background: #1e1e1e;
      color: #00ff9f;
      padding: 8px;
      border-radius: 3px;
      font-size: 10px;
      line-height: 1.3;
      overflow-x: auto;
      max-height: 100px;
      overflow-y: auto;
    }
    
    .calculation-results {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 10px;
      margin: 10px 0;
    }
    
    .result-card {
      background: #252525;
      padding: 8px;
      border-radius: 3px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.3);
      text-align: center;
      border: 1px solid #333;
    }
    
    .result-value {
      font-size: 1.4em;
      font-weight: normal;
      color: #00ff9f;
      margin: 4px 0;
      font-family: 'Consolas', monospace;
    }
    
    .result-label {
      color: #aaa;
      font-size: 9px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .result-unit {
      color: #888;
      font-size: 9px;
      margin-top: 2px;
    }
    
    #plotlyDiv {
      width: 100%;
      height: 500px;
      margin-top: 15px;
      border-radius: 3px;
      overflow: hidden;
      box-shadow: 0 1px 5px rgba(0,0,0,0.3);
    }
    
    .back-link {
      display: inline-block;
      margin-top: 20px;
      padding: 10px 20px;
      background: #333333;
      color: #e0e0e0;
      text-decoration: none;
      border-radius: 4px;
      font-family: 'Consolas', monospace;
      transition: all 0.3s;
    }
    
    .back-link:hover {
      background: #444444;
      transform: translateY(-1px);
    }

    .empty-row {
      opacity: 0.6;
    }

    /* Handsontable Dark Theme Overrides */
    .handsontable {
      background: #252525;
      color: #e0e0e0;
    }

    .handsontable th {
      background: #2a2a2a !important;
      color: #e0e0e0 !important;
      border-color: #333 !important;
      font-size: 11px;
      font-weight: normal;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .handsontable td {
      background: #252525 !important;
      color: #e0e0e0 !important;
      border-color: #333 !important;
      font-size: 12px;
    }

    .handsontable .ht_clone_top th,
    .handsontable .ht_clone_left th {
      background: #2a2a2a !important;
      color: #e0e0e0 !important;
    }

    .handsontable .ht_clone_top td,
    .handsontable .ht_clone_left td {
      background: #252525 !important;
      color: #e0e0e0 !important;
    }

    .handsontable .currentRow {
      background: #333333 !important;
    }

    .handsontable .currentCol {
      background: #333333 !important;
    }

    .handsontable .area {
      background: rgba(0, 255, 159, 0.1) !important;
      border-color: #00ff9f !important;
    }

    .handsontable .fillHandle {
      background: #00ff9f !important;
    }

    .handsontable input,
    .handsontable textarea {
      background: #252525 !important;
      color: #e0e0e0 !important;
      border-color: #333 !important;
    }

    .handsontable input:focus,
    .handsontable textarea:focus {
      background: #2a2a2a !important;
      border-color: #00ff9f !important;
      box-shadow: 0 0 0 2px rgba(0, 255, 159, 0.2) !important;
    }

    .handsontable .ht_master .wtHolder {
      background: #252525;
    }

    .handsontable .wtBorder {
      background: #00ff9f !important;
    }

    .handsontable .htContextMenu {
      background: #2a2a2a !important;
      border-color: #333 !important;
    }

    .handsontable .htContextMenu table.htCore td {
      background: #2a2a2a !important;
      color: #e0e0e0 !important;
      border-color: #333 !important;
    }

    .handsontable .htContextMenu table.htCore td.htSeparator {
      border-color: #333 !important;
    }

    .handsontable .htContextMenu table.htCore td:hover {
      background: #333333 !important;
    }

    .handsontable .htDropdownMenu {
      background: #2a2a2a !important;
      border-color: #333 !important;
    }

    .handsontable .htDropdownMenu table.htCore td {
      background: #2a2a2a !important;
      color: #e0e0e0 !important;
    }

    .handsontable .htDropdownMenu table.htCore td:hover {
      background: #333333 !important;
    }

    .handsontable .htRowHeader {
      background: #2a2a2a !important;
      color: #888 !important;
      border-color: #333 !important;
    }

    .handsontable .htColHeader {
      background: #2a2a2a !important;
      color: #888 !important;
      border-color: #333 !important;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>Structural Beam Analysis</h1>
      <p>Advanced analysis of beams with multiple supports and interactive visualization</p>
    </div>
    
    <div class="content">
      <div class="input-section">
        <div class="input-group">
          <label for="beamLength">Beam Length</label>
          <input type="number" id="beamLength" value="20" step="0.1" min="0.1">
        </div>
        <div class="input-group">
          <label for="maxDeflection">Max Deflection</label>
          <input type="number" id="maxDeflection" value="" step="0.01" min="0.01">
        </div>
        <div style="display: flex; align-items: center; gap: 8px; font-size: 10px; color: #888;">
          <span>L/360: <span id="l360Value">0.67</span></span>
          <span>L/240: <span id="l240Value">1.00</span></span>
          <span>L/180: <span id="l180Value">1.33</span></span>
        </div>
        <button class="btn-analyze" onclick="analyzeBeam()" style="margin-left: auto;">Analyze</button>
      </div>

      <div class="spreadsheet-container">
        <h3 class="spreadsheet-title">Beam Loads & Supports</h3>
        <div class="table-container" style="max-height: 400px;">
          <div id="unifiedTableHot"></div>
        </div>
      </div>

      <div id="results" class="results">
        <h3>Results</h3>
        <div class="calculation-results">
          <div class="result-card">
            <div class="result-label">Moment</div>
            <div class="result-value" id="momentValue">0.00</div>
            <div class="result-unit">kip-ft</div>
          </div>
          <div class="result-card">
            <div class="result-label">Shear</div>
            <div class="result-value" id="shearValue">0.00</div>
            <div class="result-unit">kips</div>
          </div>
          <div class="result-card">
            <div class="result-label">EI Required</div>
            <div class="result-value" id="eiValue">0.00</div>
            <div class="result-unit">(10^6) in²-lb</div>
          </div>
        </div>
        <div id="beamRepresentation" class="beam-diagram" style="display: none;"></div>
        <div id="plotlyDiv"></div>
      </div>

      <a href="index.html" class="back-link">← Back to Home</a>
    </div>
  </div>

  <script>
    // Unified Handsontable instance
    let unifiedTableHot;

    // Initialize unified Handsontable
    function initializeHandsontable() {
      const container = document.getElementById('unifiedTableHot');
      unifiedTableHot = new Handsontable(container, {
        data: [
          ['Point Load', 10, 5, null],
          ['Distributed Load', 0, 20, 1],
          ['Support', 0, 'pinned', null],
          ['Support', 20, 'roller', null]
        ],
        columns: [
          { 
            type: 'dropdown',
            title: 'Type',
            source: ['Point Load', 'Distributed Load', 'Point Moment', 'Support'],
            width: 140
          },
          { 
            type: 'numeric', 
            title: 'Location_ft',
            width: 110
          },
          { 
            type: 'numeric', 
            title: 'Load_kips | End_ft | Moment_kip_ft | Support_Type',
            width: 200
          },
          { 
            type: 'numeric', 
            title: 'Load_kips_per_ft',
            width: 140
          }
        ],
        colHeaders: true,
        rowHeaders: true,
        contextMenu: true,
        copyPaste: true,
        manualColumnResize: true,
        height: 400,
        maxRows: 200,
        licenseKey: 'non-commercial-and-evaluation',
        stretchH: 'all',
        afterChange: function(changes, source) {
          if (source === 'loadData' || !changes) return;
          
          changes.forEach(([row, col, oldValue, newValue]) => {
            // If Type column changed, clear column 3 if not Distributed Load
            if (col === 0) {
              if (newValue !== 'Distributed Load') {
                this.setDataAtCell(row, 3, null);
              }
              this.render();
            }
          });
        },
        cells: function(row, col) {
          const cellProperties = {};
          const type = this.instance.getDataAtCell(row, 0);
          
          if (col === 2) {
            // Column 2: Load_kips | End_ft | Moment_kip_ft | Support_Type
            if (type === 'Support') {
              cellProperties.type = 'dropdown';
              cellProperties.source = ['pinned', 'roller', 'fixed'];
            } else {
              cellProperties.type = 'numeric';
            }
          } else if (col === 3) {
            // Column 3: Load_kips_per_ft (only for Distributed Load)
            if (type === 'Distributed Load') {
              cellProperties.type = 'numeric';
            } else {
              cellProperties.readOnly = true;
              cellProperties.renderer = function(instance, td) {
                td.innerHTML = '';
                td.style.background = '#1e1e1e';
              };
            }
          }
          
          return cellProperties;
        }
      });
    }


    function analyzeBeam() {
      // Get input values
      const beamLength = parseFloat(document.getElementById('beamLength').value);
      
      // Get all data from unified Handsontable
      const pointLoads = [];
      const distributedLoads = [];
      const pointMoments = [];
      const supports = [];
      
      if (unifiedTableHot) {
        const data = unifiedTableHot.getData();
        data.forEach(row => {
          const type = row[0];
          const val1 = row[1];
          const val2 = row[2];
          const val3 = row[3];
          
          if (!type) return; // Skip empty rows
          
          if (type === 'Point Load') {
            const location = parseFloat(val1);
            const magnitude = parseFloat(val2);
            if (!isNaN(location) && !isNaN(magnitude) && location <= beamLength && magnitude !== 0) {
              pointLoads.push({location, magnitude: magnitude * 1000}); // Convert to pounds
            }
          } else if (type === 'Distributed Load') {
            const start = parseFloat(val1);
            const end = parseFloat(val2);
            const magnitude = parseFloat(val3);
            if (!isNaN(start) && !isNaN(end) && !isNaN(magnitude) && start < end && end <= beamLength && magnitude !== 0) {
              distributedLoads.push({start, end, magnitude: magnitude * 1000}); // Convert to pounds/ft
            }
          } else if (type === 'Point Moment') {
            const location = parseFloat(val1);
            const magnitude = parseFloat(val2);
            if (!isNaN(location) && !isNaN(magnitude) && location <= beamLength && magnitude !== 0) {
              pointMoments.push({location, magnitude}); // Keep in kip-ft
            }
          } else if (type === 'Support') {
            const location = parseFloat(val1);
            const supportType = val2;
            if (!isNaN(location) && supportType) {
              supports.push({location, type: supportType});
            }
          }
        });
      }

      // Sort loads
      pointLoads.sort((a, b) => a.location - b.location);
      distributedLoads.sort((a, b) => a.start - b.start);
      pointMoments.sort((a, b) => a.location - b.location);
      supports.sort((a, b) => a.location - b.location);

      // Validate supports
      if (supports.length < 2) {
        alert('At least 2 supports are required for a stable beam.');
        return;
      }

      // Check if beam is statically determinate
      const pinnedSupports = supports.filter(s => s.type === 'pinned').length;
      const rollerSupports = supports.filter(s => s.type === 'roller').length;
      const fixedSupports = supports.filter(s => s.type === 'fixed').length;
      
      const isDeterminate = (pinnedSupports === 1 && rollerSupports === 1 && fixedSupports === 0) ||
                           (pinnedSupports === 0 && rollerSupports === 2 && fixedSupports === 0);

      if (!isDeterminate && supports.length === 2) {
        alert('For 2 supports, you need either 1 pinned + 1 roller, or 2 rollers for a statically determinate beam.');
        return;
      }

      // Calculate reactions
      let reactions = [];
      
      if (isDeterminate) {
        reactions = calculateDeterminateReactions(beamLength, supports, pointLoads, distributedLoads, pointMoments);
      } else {
        reactions = calculateIndeterminateReactions(beamLength, supports, pointLoads, distributedLoads, pointMoments);
      }

      // Calculate internal forces
      const { V, M, x } = calculateInternalForces(beamLength, supports, reactions, pointLoads, distributedLoads, pointMoments);

      const Vu = Math.max(...V.map(Math.abs));
      const Mu = Math.max(...M.map(Math.abs));

      // Get maximum deflection limit
      const maxDeflectionInput = document.getElementById('maxDeflection').value;
      if (!maxDeflectionInput || parseFloat(maxDeflectionInput) <= 0) {
        alert('Please enter a maximum deflection limit (in inches) before calculating EI required.');
        return;
      }
      const maxDeflectionLimit = parseFloat(maxDeflectionInput);

      // Calculate deflection and EI required
      const { deflection, EIRequired } = calculateDeflectionAndEI(beamLength, supports, reactions, pointLoads, distributedLoads, pointMoments, M, x, maxDeflectionLimit);

      // Display results
      displayResults(beamLength, pointLoads, distributedLoads, pointMoments, supports, Mu, Vu, EIRequired, x, V, M);
    }

    function calculateDeterminateReactions(beamLength, supports, pointLoads, distributedLoads, pointMoments) {
      const reactions = new Array(supports.length).fill(0);
      
      if (supports.length === 2) {
        let R_left = 0, R_right = 0;

        // Point load contributions
        pointLoads.forEach(load => {
          R_left += load.magnitude * (beamLength - load.location) / beamLength;
          R_right += load.magnitude * load.location / beamLength;
        });

        // Distributed load contributions
        distributedLoads.forEach(load => {
          const length = load.end - load.start;
          const centroid = (load.start + load.end) / 2;
          const totalLoad = load.magnitude * length;
          R_left += totalLoad * (beamLength - centroid) / beamLength;
          R_right += totalLoad * centroid / beamLength;
        });

        // Point moment contributions
        // A moment creates a couple: equal and opposite forces at supports
        pointMoments.forEach(moment => {
          // Moment in kip-ft, convert to kip-in for calculation, then back
          const moment_kips = moment.magnitude; // Already in kip-ft
          // The moment creates a vertical force couple: M/L
          const forceCouple = moment_kips / beamLength; // kips
          // Direction depends on moment direction (positive = counterclockwise)
          // For a moment at location x, it creates R_left = -M/L and R_right = M/L
          R_left -= forceCouple * 1000; // Convert to pounds
          R_right += forceCouple * 1000;
        });

        reactions[0] = R_left / 1000; // Convert to kips
        reactions[1] = R_right / 1000;
      }
      
      return reactions;
    }

    function calculateIndeterminateReactions(beamLength, supports, pointLoads, distributedLoads, pointMoments) {
      const reactions = new Array(supports.length).fill(0);
      
      let totalLoad = 0;
      pointLoads.forEach(load => totalLoad += load.magnitude);
      distributedLoads.forEach(load => {
        totalLoad += load.magnitude * (load.end - load.start);
      });

      // For indeterminate beams, moments create additional reactions
      // Simplified approach: distribute moment effects proportionally
      let totalMomentEffect = 0;
      pointMoments.forEach(moment => {
        totalMomentEffect += Math.abs(moment.magnitude);
      });

      const loadPerSupport = totalLoad / supports.length;
      const momentEffectPerSupport = totalMomentEffect / (beamLength * supports.length);
      
      reactions.fill((loadPerSupport + momentEffectPerSupport * 1000) / 1000);
      
      return reactions;
    }

    function calculateInternalForces(beamLength, supports, reactions, pointLoads, distributedLoads, pointMoments) {
      const numPoints = 1000;
      const x = [];
      const V = [];
      const M = [];

      for (let i = 0; i < numPoints; i++) {
        const x_val = (i / (numPoints - 1)) * beamLength;
        x.push(x_val);

        let V_val = 0;
        
        supports.forEach((support, index) => {
          if (x_val >= support.location) {
            V_val += reactions[index];
          }
        });

        pointLoads.forEach(load => {
          if (x_val > load.location) {
            V_val -= load.magnitude / 1000;
          }
        });

        distributedLoads.forEach(load => {
          if (x_val >= load.start && x_val <= load.end) {
            V_val -= (load.magnitude * (x_val - load.start)) / 1000;
          } else if (x_val > load.end) {
            V_val -= (load.magnitude * (load.end - load.start)) / 1000;
          }
        });

        V.push(V_val);
      }

      M[0] = 0;
      for (let i = 1; i < numPoints; i++) {
        const dx = x[i] - x[i-1];
        M[i] = M[i-1] + (V[i-1] + V[i]) * dx / 2;
      }
      
      // Apply point moments - they create step changes (discontinuities) in the moment diagram
      // Moments are applied at their exact location, creating a jump in the moment
      pointMoments.forEach(moment => {
        const momentIndex = Math.round((moment.location / beamLength) * (numPoints - 1));
        // Add the moment to all points after the moment location
        for (let i = momentIndex + 1; i < numPoints; i++) {
          M[i] += moment.magnitude;
        }
      });

      if (supports.length >= 2) {
        const leftSupport = Math.min(...supports.map(s => s.location));
        const leftIndex = Math.round((leftSupport / beamLength) * (numPoints - 1));
        
        if (leftIndex >= 0 && leftIndex < M.length) {
          const leftMoment = M[leftIndex];
          for (let i = 0; i < M.length; i++) {
            M[i] -= leftMoment;
          }
        }
      }

      return { V, M, x };
    }

    function calculateDeflectionAndEI(beamLength, supports, reactions, pointLoads, distributedLoads, pointMoments, M, x, deflectionLimit_in) {
      // Calculate deflection using numerical integration of moment diagram
      // Deflection = ∫∫(M/EI) dx dx
      // We'll calculate assuming EI = 1, then scale based on deflection limit
      const numPoints = M.length;
      
      // Convert moment from kip-ft to kip-in and assume EI = 1 kip-in²
      // So curvature = M (in kip-in) / 1 = M (in kip-in)
      const curvature = M.map(m => m * 12); // Convert kip-ft to kip-in
      
      // First integration: slope (radians)
      const slope = [0];
      for (let i = 1; i < numPoints; i++) {
        const dx_ft = x[i] - x[i-1];
        const dx_in = dx_ft * 12; // Convert to inches
        // Trapezoidal integration
        slope.push(slope[i-1] + (curvature[i-1] + curvature[i]) * dx_in / 2);
      }
      
      // Adjust slope to satisfy boundary conditions at supports
      // For pinned/roller supports, slope may not be zero, but we'll account for this
      const leftSupportIndex = supports.length > 0 ? 
        Math.round((Math.min(...supports.map(s => s.location)) / beamLength) * (numPoints - 1)) : 0;
      
      // Second integration: deflection (inches)
      const deflection = [0];
      for (let i = 1; i < numPoints; i++) {
        const dx_ft = x[i] - x[i-1];
        const dx_in = dx_ft * 12; // Convert to inches
        // Trapezoidal integration
        deflection.push(deflection[i-1] + (slope[i-1] + slope[i]) * dx_in / 2);
      }
      
      // Adjust deflection so it's zero at left support
      if (leftSupportIndex >= 0 && leftSupportIndex < deflection.length) {
        const deflectionOffset = deflection[leftSupportIndex];
        for (let i = 0; i < deflection.length; i++) {
          deflection[i] -= deflectionOffset;
        }
      }
      
      // Find maximum deflection (absolute value)
      const maxDeflection = Math.max(...deflection.map(Math.abs));
      
      // Use user-provided deflection limit (in inches)
      // Since we calculated deflection assuming EI = 1 kip-in²,
      // actual deflection = calculated_deflection / actual_EI
      // So: actual_EI = calculated_deflection / actual_deflection
      // For required EI: EI_required = calculated_deflection / deflection_limit
      // Units: deflection is in inches, so EI will be in kip-in²
      // Convert to lb-in²: 1 kip = 1000 lb
      const EIRequired_kip_in2 = maxDeflection / deflectionLimit_in;
      const EIRequired_lb_in2 = EIRequired_kip_in2 * 1000;
      
      // Convert to (10^6) in²-lb format for display
      const EIRequired = EIRequired_lb_in2 / 1000000;
      
      return { deflection: maxDeflection, EIRequired };
    }

    function displayResults(beamLength, pointLoads, distributedLoads, pointMoments, supports, Mu, Vu, EIRequired, x, V, M) {
      document.getElementById('results').style.display = 'block';
      document.getElementById('beamRepresentation').style.display = 'block';

      let beamRep = 'Multi-Support Beam:\n';
      beamRep += 'A' + '─'.repeat(Math.floor(beamLength * 2)) + 'B\n';
      
      supports.forEach(support => {
        const pos = Math.floor(support.location * 2);
        const supportSymbol = support.type === 'pinned' ? '▲' : 
                             support.type === 'roller' ? '▼' : '◆';
        beamRep += ' '.repeat(pos) + `${supportSymbol} ${support.type.charAt(0).toUpperCase() + support.type.slice(1)} Support\n`;
      });

      pointLoads.forEach(load => {
        const pos = Math.floor(load.location * 2);
        beamRep += ' '.repeat(pos) + `↓ Pu = ${(load.magnitude/1000).toFixed(2)} kips\n`;
      });

      distributedLoads.forEach(load => {
        const startPos = Math.floor(load.start * 2);
        const length = Math.floor((load.end - load.start) * 2);
        beamRep += ' '.repeat(startPos) + '═'.repeat(length) + ` w = ${(load.magnitude/1000).toFixed(2)} kips/ft\n`;
      });

      pointMoments.forEach(moment => {
        const pos = Math.floor(moment.location * 2);
        const momentSymbol = moment.magnitude > 0 ? '↻' : '↺';
        beamRep += ' '.repeat(pos) + `${momentSymbol} Mu = ${moment.magnitude.toFixed(2)} kip-ft\n`;
      });

      document.getElementById('beamRepresentation').textContent = beamRep;

      document.getElementById('momentValue').textContent = Mu.toFixed(2);
      document.getElementById('shearValue').textContent = Vu.toFixed(2);
      document.getElementById('eiValue').textContent = EIRequired.toFixed(2);

      const trace1 = {
        x: x,
        y: V,
        type: 'scatter',
        mode: 'lines',
        name: 'Shear Force',
        line: {
          color: '#00ff9f', /* Green for dark mode */
          width: 3
        },
        fill: 'tozeroy',
        fillcolor: 'rgba(0, 255, 159, 0.1)',
        hovertemplate: '<b>Shear Force</b><br>Position: %{x:.2f} ft<br>Shear: %{y:.2f} kips<extra></extra>'
      };

      const trace2 = {
        x: x,
        y: M,
        type: 'scatter',
        mode: 'lines',
        name: 'Bending Moment',
        line: {
          color: '#ff5555', /* Red for contrast */
          width: 3
        },
        fill: 'tozeroy',
        fillcolor: 'rgba(255, 85, 85, 0.1)',
        yaxis: 'y2',
        hovertemplate: '<b>Bending Moment</b><br>Position: %{x:.2f} ft<br>Moment: %{y:.2f} kip-ft<extra></extra>'
      };

      const layout = {
        title: {
          text: 'Beam Analysis - Shear Force and Bending Moment Diagrams',
          font: { size: 20, color: '#ecf0f1' } /* Light text */
        },
        xaxis: {
          title: { text: 'Position along beam (ft)', font: { size: 14, color: '#e0e0e0' } },
          gridcolor: '#444', /* Darker gridlines */
          zeroline: true,
          zerolinecolor: '#555',
          zerolinewidth: 2
        },
        yaxis: {
          title: { text: 'Shear Force (kips)', font: { size: 14, color: '#00ff9f' } },
          side: 'left',
          gridcolor: '#444',
          zeroline: true,
          zerolinecolor: '#555',
          zerolinewidth: 2
        },
        yaxis2: {
          title: { text: 'Bending Moment (kip-ft)', font: { size: 14, color: '#ff5555' } },
          side: 'right',
          overlaying: 'y',
          gridcolor: '#444',
          zeroline: true,
          zerolinecolor: '#555',
          zerolinewidth: 2
        },
        height: 500,
        plot_bgcolor: '#1e1e1e', /* Dark plot background */
        paper_bgcolor: '#1e1e1e', /* Dark paper background */
        font: { family: 'Consolas, monospace', color: '#e0e0e0' },
        legend: {
          x: 1,
          y: 1,
          bgcolor: 'rgba(37, 37, 37, 0.8)', /* Matches styles.css */
          bordercolor: '#333',
          borderwidth: 1
        },
        margin: { l: 60, r: 60, t: 60, b: 60 }
      };

      Plotly.newPlot('plotlyDiv', [trace1, trace2], layout, {
        responsive: true,
        displayModeBar: true,
        modeBarButtonsToRemove: ['select2d', 'lasso2d'],
        displaylogo: false
      });

      // Results are always visible, no need to scroll
    }


    function updateDefaultValues() {
      const beamLength = parseFloat(document.getElementById('beamLength').value) || 20;
      const midLength = beamLength / 2;
      
      // Update point load location to midlength in unified table
      if (unifiedTableHot) {
        const data = unifiedTableHot.getData();
        data.forEach((row, index) => {
          if (row[0] === 'Point Load') {
            unifiedTableHot.setDataAtCell(index, 1, midLength.toFixed(1));
          } else if (row[0] === 'Distributed Load') {
            unifiedTableHot.setDataAtCell(index, 1, 0);
            unifiedTableHot.setDataAtCell(index, 2, beamLength.toFixed(1));
          }
        });
      }
      
      // Update deflection limit helper values
      const l360Value = (beamLength * 12) / 360;
      const l240Value = (beamLength * 12) / 240;
      const l180Value = (beamLength * 12) / 180;
      
      const l360Span = document.getElementById('l360Value');
      const l240Span = document.getElementById('l240Value');
      const l180Span = document.getElementById('l180Value');
      
      if (l360Span) l360Span.textContent = l360Value.toFixed(2);
      if (l240Span) l240Span.textContent = l240Value.toFixed(2);
      if (l180Span) l180Span.textContent = l180Value.toFixed(2);
      
      // Set default deflection limit to L/360 if empty
      const maxDeflectionInput = document.getElementById('maxDeflection');
      if (maxDeflectionInput && !maxDeflectionInput.value) {
        maxDeflectionInput.value = l360Value.toFixed(2);
      }
    }

    // Update defaults when beam length changes
    document.getElementById('beamLength').addEventListener('input', updateDefaultValues);

    window.onload = function() {
      initializeHandsontable();
      updateDefaultValues();
      analyzeBeam();
    };
  </script>
</body>
</html>