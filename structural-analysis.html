<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Structural Analysis - Kafka Design</title>
  <link rel="stylesheet" href="src/reset.css">
  <link rel="stylesheet" href="src/index.css">
  <link rel="stylesheet" href="css/styles.css">
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <style>
    * {
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Consolas', monospace; /* Matches styles.css */
      background: #1b1b1b; /* Dark background */
      margin: 0;
      padding: 20px;
      min-height: 100vh;
      color: #e0e0e0; /* Light gray text */
    }
    
    .container {
      max-width: 1200px;
      margin: 0 auto;
      background: #252525; /* Slightly lighter dark */
      border-radius: 4px; /* Minimal for terminal look */
      box-shadow: 0 2px 10px rgba(0,0,0,0.5);
      overflow: hidden;
    }
    
    .header {
      background: #1e1e1e; /* Darker background */
      color: #ecf0f1;
      padding: 20px;
      text-align: center;
    }
    
    .header h1 {
      margin: 0;
      font-size: 1.8em;
      font-weight: normal; /* Monospace Web style */
    }
    
    .header p {
      margin: 8px 0 0 0;
      opacity: 0.8;
      font-size: 1em;
    }
    
    .content {
      padding: 20px;
    }
    
    .input-section {
      margin-bottom: 20px;
    }
    
    .input-group {
      margin: 15px 0;
    }
    
    .input-group label {
      display: block;
      margin-bottom: 6px;
      font-weight: normal;
      color: #e0e0e0;
      font-size: 1em;
    }
    
    .input-group input {
      width: 200px;
      padding: 10px;
      border: 1px solid #333; /* Matches styles.css */
      border-radius: 3px;
      font-size: 14px;
      background: #2a2a2a;
      color: #e0e0e0;
      font-family: 'Consolas', monospace;
      transition: border-color 0.3s;
    }
    
    .input-group input:focus {
      outline: none;
      border-color: #00ff9f; /* Green accent from styles.css */
      box-shadow: 0 0 0 2px rgba(0, 255, 159, 0.2);
    }
    
    .spreadsheet-container {
      margin: 20px 0;
      border-radius: 4px;
      overflow: hidden;
      box-shadow: 0 2px 10px rgba(0,0,0,0.3);
    }
    
    .spreadsheet-title {
      background: #2a2a2a;
      color: #00ff9f;
      padding: 12px 15px;
      margin: 0;
      font-size: 1.2em;
      font-weight: normal;
    }
    
    .table-container {
      overflow-x: auto;
      background: #252525;
    }
    
    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 14px;
      font-family: 'Consolas', monospace;
    }
    
    th {
      background: #2a2a2a;
      padding: 12px;
      text-align: left;
      font-weight: normal;
      color: #e0e0e0;
      border-bottom: 1px solid #333;
    }
    
    td {
      padding: 12px;
      border-bottom: 1px solid #333;
      vertical-align: middle;
      color: #e0e0e0;
    }
    
    tr:hover {
      background-color: #333333; /* Matches styles.css */
    }
    
    .table-input {
      width: 100%;
      padding: 8px;
      border: 1px solid #333;
      border-radius: 3px;
      font-size: 14px;
      background: #2a2a2a;
      color: #e0e0e0;
      font-family: 'Consolas', monospace;
      transition: border-color 0.3s;
    }
    
    .table-input:focus {
      outline: none;
      border-color: #00ff9f;
      box-shadow: 0 0 0 2px rgba(0, 255, 159, 0.2);
    }
    
    .btn {
      padding: 8px 12px;
      border: none;
      border-radius: 3px;
      cursor: pointer;
      font-size: 13px;
      font-weight: normal;
      font-family: 'Consolas', monospace;
      transition: all 0.3s;
    }
    
    .btn-add {
      background: #00ff9f; /* Green accent */
      color: #1e1e1e;
      margin: 15px 0;
      padding: 10px 20px;
      font-size: 14px;
    }
    
    .btn-add:hover {
      background: #00cc7f;
      transform: translateY(-1px);
    }
    
    .btn-remove {
      background: #ff5555; /* Red for remove */
      color: #e0e0e0;
    }
    
    .btn-remove:hover {
      background: #cc4444;
    }
    
    .btn-analyze {
      background: #00ff9f;
      color: #1e1e1e;
      padding: 15px 40px;
      font-size: 18px;
      font-weight: normal;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      margin: 20px 0;
      transition: all 0.3s;
      box-shadow: 0 2px 10px rgba(0, 255, 159, 0.3);
    }
    
    .btn-analyze:hover {
      background: #00cc7f;
      transform: translateY(-2px);
      box-shadow: 0 4px 15px rgba(0, 255, 159, 0.4);
    }
    
    .results {
      margin-top: 20px;
      padding: 20px;
      background: #2a2a2a;
      border-radius: 4px;
      box-shadow: inset 0 2px 10px rgba(0,0,0,0.3);
    }
    
    .results h3 {
      color: #ecf0f1;
      margin-top: 0;
      font-size: 1.3em;
      font-weight: normal;
    }
    
    .beam-diagram {
      margin: 15px 0;
      font-family: 'Consolas', monospace;
      background: #1e1e1e;
      color: #00ff9f; /* Green for terminal effect */
      padding: 15px;
      border-radius: 4px;
      font-size: 14px;
      line-height: 1.4;
      overflow-x: auto;
    }
    
    .calculation-results {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 15px;
      margin: 15px 0;
    }
    
    .result-card {
      background: #252525;
      padding: 15px;
      border-radius: 4px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.3);
      text-align: center;
    }
    
    .result-value {
      font-size: 1.8em;
      font-weight: normal;
      color: #00ff9f;
      margin: 8px 0;
    }
    
    .result-label {
      color: #aaa;
      font-size: 0.8em;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    
    #plotlyDiv {
      width: 100%;
      height: 700px;
      margin-top: 20px;
      border-radius: 4px;
      overflow: hidden;
      box-shadow: 0 2px 10px rgba(0,0,0,0.3);
    }
    
    .back-link {
      display: inline-block;
      margin-top: 20px;
      padding: 10px 20px;
      background: #333333;
      color: #e0e0e0;
      text-decoration: none;
      border-radius: 4px;
      font-family: 'Consolas', monospace;
      transition: all 0.3s;
    }
    
    .back-link:hover {
      background: #444444;
      transform: translateY(-1px);
    }

    .empty-row {
      opacity: 0.6;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>Structural Beam Analysis</h1>
      <p>Advanced analysis of beams with multiple supports and interactive visualization</p>
    </div>
    
    <div class="content">
      <div class="input-section">
        <div class="input-group">
          <label for="beamLength">Beam Length (ft):</label>
          <input type="number" id="beamLength" value="20" step="0.1" min="0.1">
        </div>
        <div class="input-group">
          <label for="maxDeflection">Maximum Deflection Limit (in):</label>
          <input type="number" id="maxDeflection" value="" step="0.01" min="0.01" placeholder="e.g., L/360 = 0.67">
          <p style="margin-top: 5px; font-size: 0.85em; color: #aaa;">
            Common values: L/360 = <span id="l360Value">0.67</span> in, L/240 = <span id="l240Value">1.00</span> in, L/180 = <span id="l180Value">1.33</span> in
          </p>
        </div>
      </div>

      <div class="spreadsheet-container">
        <h3 class="spreadsheet-title">Point Loads</h3>
        <div class="table-container">
          <table id="pointLoadsTable">
            <thead>
              <tr>
                <th>Location (ft)</th>
                <th>Load (kips)</th>
                <th>Action</th>
              </tr>
            </thead>
            <tbody id="pointLoadsBody">
              <tr>
                <td><input type="number" class="table-input point-location" value="10" step="0.1" min="0" id="defaultPointLocation"></td>
                <td><input type="number" class="table-input point-magnitude" value="5" step="0.1"></td>
                <td><button class="btn btn-remove" onclick="removeRow(this)">Remove</button></td>
              </tr>
              <tr class="empty-row">
                <td><input type="number" class="table-input point-location" value="" step="0.1" min="0" placeholder="Enter location"></td>
                <td><input type="number" class="table-input point-magnitude" value="" step="0.1" placeholder="Enter load"></td>
                <td><button class="btn btn-remove" onclick="removeRow(this)">Remove</button></td>
              </tr>
            </tbody>
          </table>
        </div>
        <button class="btn btn-add" onclick="addPointLoad()">+ Add Point Load</button>
      </div>

      <div class="spreadsheet-container">
        <h3 class="spreadsheet-title">Distributed Loads</h3>
        <div class="table-container">
          <table id="distributedLoadsTable">
            <thead>
              <tr>
                <th>Start (ft)</th>
                <th>End (ft)</th>
                <th>Load (kips/ft)</th>
                <th>Action</th>
              </tr>
            </thead>
            <tbody id="distributedLoadsBody">
              <tr>
                <td><input type="number" class="table-input dist-start" value="0" step="0.1" min="0" id="defaultDistStart"></td>
                <td><input type="number" class="table-input dist-end" value="20" step="0.1" min="0" id="defaultDistEnd"></td>
                <td><input type="number" class="table-input dist-magnitude" value="1" step="0.1"></td>
                <td><button class="btn btn-remove" onclick="removeRow(this)">Remove</button></td>
              </tr>
              <tr class="empty-row">
                <td><input type="number" class="table-input dist-start" value="" step="0.1" min="0" placeholder="Start"></td>
                <td><input type="number" class="table-input dist-end" value="" step="0.1" min="0" placeholder="End"></td>
                <td><input type="number" class="table-input dist-magnitude" value="" step="0.1" placeholder="Load"></td>
                <td><button class="btn btn-remove" onclick="removeRow(this)">Remove</button></td>
              </tr>
            </tbody>
          </table>
        </div>
        <button class="btn btn-add" onclick="addDistributedLoad()">+ Add Distributed Load</button>
      </div>

      <div class="spreadsheet-container">
        <h3 class="spreadsheet-title">Point Moments</h3>
        <div class="table-container">
          <table id="pointMomentsTable">
            <thead>
              <tr>
                <th>Location (ft)</th>
                <th>Moment (kip-ft)</th>
                <th>Action</th>
              </tr>
            </thead>
            <tbody id="pointMomentsBody">
              <tr class="empty-row">
                <td><input type="number" class="table-input moment-location" value="" step="0.1" min="0" placeholder="Enter location"></td>
                <td><input type="number" class="table-input moment-magnitude" value="" step="0.1" placeholder="Enter moment"></td>
                <td><button class="btn btn-remove" onclick="removeRow(this)">Remove</button></td>
              </tr>
            </tbody>
          </table>
        </div>
        <button class="btn btn-add" onclick="addPointMoment()">+ Add Point Moment</button>
      </div>

      <div class="spreadsheet-container">
        <h3 class="spreadsheet-title">Support Locations</h3>
        <div class="table-container">
          <table id="supportsTable">
            <thead>
              <tr>
                <th>Location (ft)</th>
                <th>Support Type</th>
                <th>Action</th>
              </tr>
            </thead>
            <tbody id="supportsBody">
              <tr>
                <td><input type="number" class="table-input support-location" value="0" step="0.1" min="0"></td>
                <td>
                  <select class="table-input support-type">
                    <option value="pinned" selected>Pinned</option>
                    <option value="roller">Roller</option>
                    <option value="fixed">Fixed</option>
                  </select>
                </td>
                <td><button class="btn btn-remove" onclick="removeRow(this)">Remove</button></td>
              </tr>
              <tr>
                <td><input type="number" class="table-input support-location" value="20" step="0.1" min="0"></td>
                <td>
                  <select class="table-input support-type">
                    <option value="pinned">Pinned</option>
                    <option value="roller" selected>Roller</option>
                    <option value="fixed">Fixed</option>
                  </select>
                </td>
                <td><button class="btn btn-remove" onclick="removeRow(this)">Remove</button></td>
              </tr>
              <tr class="empty-row">
                <td><input type="number" class="table-input support-location" value="" step="0.1" min="0" placeholder="Enter location"></td>
                <td>
                  <select class="table-input support-type">
                    <option value="pinned">Pinned</option>
                    <option value="roller">Roller</option>
                    <option value="fixed">Fixed</option>
                  </select>
                </td>
                <td><button class="btn btn-remove" onclick="removeRow(this)">Remove</button></td>
              </tr>
            </tbody>
          </table>
        </div>
        <button class="btn btn-add" onclick="addSupport()">+ Add Support</button>
        <p style="margin-top: 10px; font-size: 0.9em; color: #aaa;">
          <strong>Note:</strong> For statically determinate beams, you need exactly one pinned support and one roller support. 
          For indeterminate beams, you can add more supports.
        </p>
      </div>

      <div style="text-align: center;">
        <button class="btn-analyze" onclick="analyzeBeam()">üîç Analyze Beam</button>
      </div>

      <div id="results" class="results" style="display: none;">
        <h3>Analysis Results</h3>
        <div id="beamRepresentation" class="beam-diagram"></div>
        <div class="calculation-results">
          <div class="result-card">
            <div class="result-label">Ultimate Moment</div>
            <div class="result-value" id="momentValue">0.00</div>
            <div>kip-ft</div>
          </div>
          <div class="result-card">
            <div class="result-label">Ultimate Shear</div>
            <div class="result-value" id="shearValue">0.00</div>
            <div>kips</div>
          </div>
          <div class="result-card">
            <div class="result-label">EI Required</div>
            <div class="result-value" id="eiValue">0.00</div>
            <div>(10^6) in¬≤-lb</div>
          </div>
        </div>
        <div id="plotlyDiv"></div>
      </div>

      <a href="index.html" class="back-link">‚Üê Back to Home</a>
    </div>
  </div>

  <script>
    function addPointLoad() {
      const tbody = document.getElementById('pointLoadsBody');
      const newRow = document.createElement('tr');
      newRow.innerHTML = `
        <td><input type="number" class="table-input point-location" value="" step="0.1" min="0" placeholder="Enter location"></td>
        <td><input type="number" class="table-input point-magnitude" value="" step="0.1" placeholder="Enter load"></td>
        <td><button class="btn btn-remove" onclick="removeRow(this)">Remove</button></td>
      `;
      tbody.appendChild(newRow);
    }

    function addDistributedLoad() {
      const tbody = document.getElementById('distributedLoadsBody');
      const newRow = document.createElement('tr');
      newRow.innerHTML = `
        <td><input type="number" class="table-input dist-start" value="" step="0.1" min="0" placeholder="Start"></td>
        <td><input type="number" class="table-input dist-end" value="" step="0.1" min="0" placeholder="End"></td>
        <td><input type="number" class="table-input dist-magnitude" value="" step="0.1" placeholder="Load"></td>
        <td><button class="btn btn-remove" onclick="removeRow(this)">Remove</button></td>
      `;
      tbody.appendChild(newRow);
    }

    function addPointMoment() {
      const tbody = document.getElementById('pointMomentsBody');
      const newRow = document.createElement('tr');
      newRow.innerHTML = `
        <td><input type="number" class="table-input moment-location" value="" step="0.1" min="0" placeholder="Enter location"></td>
        <td><input type="number" class="table-input moment-magnitude" value="" step="0.1" placeholder="Enter moment"></td>
        <td><button class="btn btn-remove" onclick="removeRow(this)">Remove</button></td>
      `;
      tbody.appendChild(newRow);
    }

    function addSupport() {
      const tbody = document.getElementById('supportsBody');
      const newRow = document.createElement('tr');
      newRow.innerHTML = `
        <td><input type="number" class="table-input support-location" value="" step="0.1" min="0" placeholder="Enter location"></td>
        <td>
          <select class="table-input support-type">
            <option value="pinned">Pinned</option>
            <option value="roller">Roller</option>
            <option value="fixed">Fixed</option>
          </select>
        </td>
        <td><button class="btn btn-remove" onclick="removeRow(this)">Remove</button></td>
      `;
      tbody.appendChild(newRow);
    }

    function removeRow(button) {
      const row = button.closest('tr');
      const tbody = row.parentNode;
      
      // Don't remove if it's the last row in the table
      if (tbody.children.length > 1) {
        row.remove();
      } else {
        // Clear the inputs instead
        row.querySelectorAll('input').forEach(input => input.value = '');
      }
    }

    function analyzeBeam() {
      // Get input values
      const beamLength = parseFloat(document.getElementById('beamLength').value);
      
      // Get point loads from table
      const pointLoads = [];
      document.querySelectorAll('#pointLoadsBody tr').forEach(row => {
        const location = parseFloat(row.querySelector('.point-location').value);
        const magnitude = parseFloat(row.querySelector('.point-magnitude').value);
        if (!isNaN(location) && !isNaN(magnitude) && location <= beamLength && magnitude !== 0) {
          pointLoads.push({location, magnitude: magnitude * 1000}); // Convert to pounds
        }
      });

      // Get distributed loads from table
      const distributedLoads = [];
      document.querySelectorAll('#distributedLoadsBody tr').forEach(row => {
        const start = parseFloat(row.querySelector('.dist-start').value);
        const end = parseFloat(row.querySelector('.dist-end').value);
        const magnitude = parseFloat(row.querySelector('.dist-magnitude').value);
        if (!isNaN(start) && !isNaN(end) && !isNaN(magnitude) && start < end && end <= beamLength && magnitude !== 0) {
          distributedLoads.push({start, end, magnitude: magnitude * 1000}); // Convert to pounds/ft
        }
      });

      // Get point moments from table
      const pointMoments = [];
      document.querySelectorAll('#pointMomentsBody tr').forEach(row => {
        const location = parseFloat(row.querySelector('.moment-location').value);
        const magnitude = parseFloat(row.querySelector('.moment-magnitude').value);
        if (!isNaN(location) && !isNaN(magnitude) && location <= beamLength && magnitude !== 0) {
          pointMoments.push({location, magnitude}); // Keep in kip-ft
        }
      });

      // Get supports from table
      const supports = [];
      document.querySelectorAll('#supportsBody tr').forEach(row => {
        const location = parseFloat(row.querySelector('.support-location').value);
        const type = row.querySelector('.support-type').value;
        if (!isNaN(location) && type) {
          supports.push({location, type});
        }
      });

      // Sort loads
      pointLoads.sort((a, b) => a.location - b.location);
      distributedLoads.sort((a, b) => a.start - b.start);
      pointMoments.sort((a, b) => a.location - b.location);
      supports.sort((a, b) => a.location - b.location);

      // Validate supports
      if (supports.length < 2) {
        alert('At least 2 supports are required for a stable beam.');
        return;
      }

      // Check if beam is statically determinate
      const pinnedSupports = supports.filter(s => s.type === 'pinned').length;
      const rollerSupports = supports.filter(s => s.type === 'roller').length;
      const fixedSupports = supports.filter(s => s.type === 'fixed').length;
      
      const isDeterminate = (pinnedSupports === 1 && rollerSupports === 1 && fixedSupports === 0) ||
                           (pinnedSupports === 0 && rollerSupports === 2 && fixedSupports === 0);

      if (!isDeterminate && supports.length === 2) {
        alert('For 2 supports, you need either 1 pinned + 1 roller, or 2 rollers for a statically determinate beam.');
        return;
      }

      // Calculate reactions
      let reactions = [];
      
      if (isDeterminate) {
        reactions = calculateDeterminateReactions(beamLength, supports, pointLoads, distributedLoads, pointMoments);
      } else {
        reactions = calculateIndeterminateReactions(beamLength, supports, pointLoads, distributedLoads, pointMoments);
      }

      // Calculate internal forces
      const { V, M, x } = calculateInternalForces(beamLength, supports, reactions, pointLoads, distributedLoads, pointMoments);

      const Vu = Math.max(...V.map(Math.abs));
      const Mu = Math.max(...M.map(Math.abs));

      // Get maximum deflection limit
      const maxDeflectionInput = document.getElementById('maxDeflection').value;
      if (!maxDeflectionInput || parseFloat(maxDeflectionInput) <= 0) {
        alert('Please enter a maximum deflection limit (in inches) before calculating EI required.');
        return;
      }
      const maxDeflectionLimit = parseFloat(maxDeflectionInput);

      // Calculate deflection and EI required
      const { deflection, EIRequired } = calculateDeflectionAndEI(beamLength, supports, reactions, pointLoads, distributedLoads, pointMoments, M, x, maxDeflectionLimit);

      // Display results
      displayResults(beamLength, pointLoads, distributedLoads, pointMoments, supports, Mu, Vu, EIRequired, x, V, M);
    }

    function calculateDeterminateReactions(beamLength, supports, pointLoads, distributedLoads, pointMoments) {
      const reactions = new Array(supports.length).fill(0);
      
      if (supports.length === 2) {
        let R_left = 0, R_right = 0;

        // Point load contributions
        pointLoads.forEach(load => {
          R_left += load.magnitude * (beamLength - load.location) / beamLength;
          R_right += load.magnitude * load.location / beamLength;
        });

        // Distributed load contributions
        distributedLoads.forEach(load => {
          const length = load.end - load.start;
          const centroid = (load.start + load.end) / 2;
          const totalLoad = load.magnitude * length;
          R_left += totalLoad * (beamLength - centroid) / beamLength;
          R_right += totalLoad * centroid / beamLength;
        });

        // Point moment contributions
        // A moment creates a couple: equal and opposite forces at supports
        pointMoments.forEach(moment => {
          // Moment in kip-ft, convert to kip-in for calculation, then back
          const moment_kips = moment.magnitude; // Already in kip-ft
          // The moment creates a vertical force couple: M/L
          const forceCouple = moment_kips / beamLength; // kips
          // Direction depends on moment direction (positive = counterclockwise)
          // For a moment at location x, it creates R_left = -M/L and R_right = M/L
          R_left -= forceCouple * 1000; // Convert to pounds
          R_right += forceCouple * 1000;
        });

        reactions[0] = R_left / 1000; // Convert to kips
        reactions[1] = R_right / 1000;
      }
      
      return reactions;
    }

    function calculateIndeterminateReactions(beamLength, supports, pointLoads, distributedLoads, pointMoments) {
      const reactions = new Array(supports.length).fill(0);
      
      let totalLoad = 0;
      pointLoads.forEach(load => totalLoad += load.magnitude);
      distributedLoads.forEach(load => {
        totalLoad += load.magnitude * (load.end - load.start);
      });

      // For indeterminate beams, moments create additional reactions
      // Simplified approach: distribute moment effects proportionally
      let totalMomentEffect = 0;
      pointMoments.forEach(moment => {
        totalMomentEffect += Math.abs(moment.magnitude);
      });

      const loadPerSupport = totalLoad / supports.length;
      const momentEffectPerSupport = totalMomentEffect / (beamLength * supports.length);
      
      reactions.fill((loadPerSupport + momentEffectPerSupport * 1000) / 1000);
      
      return reactions;
    }

    function calculateInternalForces(beamLength, supports, reactions, pointLoads, distributedLoads, pointMoments) {
      const numPoints = 1000;
      const x = [];
      const V = [];
      const M = [];

      for (let i = 0; i < numPoints; i++) {
        const x_val = (i / (numPoints - 1)) * beamLength;
        x.push(x_val);

        let V_val = 0;
        
        supports.forEach((support, index) => {
          if (x_val >= support.location) {
            V_val += reactions[index];
          }
        });

        pointLoads.forEach(load => {
          if (x_val > load.location) {
            V_val -= load.magnitude / 1000;
          }
        });

        distributedLoads.forEach(load => {
          if (x_val >= load.start && x_val <= load.end) {
            V_val -= (load.magnitude * (x_val - load.start)) / 1000;
          } else if (x_val > load.end) {
            V_val -= (load.magnitude * (load.end - load.start)) / 1000;
          }
        });

        V.push(V_val);
      }

      M[0] = 0;
      for (let i = 1; i < numPoints; i++) {
        const dx = x[i] - x[i-1];
        M[i] = M[i-1] + (V[i-1] + V[i]) * dx / 2;
      }
      
      // Apply point moments - they create step changes (discontinuities) in the moment diagram
      // Moments are applied at their exact location, creating a jump in the moment
      pointMoments.forEach(moment => {
        const momentIndex = Math.round((moment.location / beamLength) * (numPoints - 1));
        // Add the moment to all points after the moment location
        for (let i = momentIndex + 1; i < numPoints; i++) {
          M[i] += moment.magnitude;
        }
      });

      if (supports.length >= 2) {
        const leftSupport = Math.min(...supports.map(s => s.location));
        const leftIndex = Math.round((leftSupport / beamLength) * (numPoints - 1));
        
        if (leftIndex >= 0 && leftIndex < M.length) {
          const leftMoment = M[leftIndex];
          for (let i = 0; i < M.length; i++) {
            M[i] -= leftMoment;
          }
        }
      }

      return { V, M, x };
    }

    function calculateDeflectionAndEI(beamLength, supports, reactions, pointLoads, distributedLoads, pointMoments, M, x, deflectionLimit_in) {
      // Calculate deflection using numerical integration of moment diagram
      // Deflection = ‚à´‚à´(M/EI) dx dx
      // We'll calculate assuming EI = 1, then scale based on deflection limit
      const numPoints = M.length;
      
      // Convert moment from kip-ft to kip-in and assume EI = 1 kip-in¬≤
      // So curvature = M (in kip-in) / 1 = M (in kip-in)
      const curvature = M.map(m => m * 12); // Convert kip-ft to kip-in
      
      // First integration: slope (radians)
      const slope = [0];
      for (let i = 1; i < numPoints; i++) {
        const dx_ft = x[i] - x[i-1];
        const dx_in = dx_ft * 12; // Convert to inches
        // Trapezoidal integration
        slope.push(slope[i-1] + (curvature[i-1] + curvature[i]) * dx_in / 2);
      }
      
      // Adjust slope to satisfy boundary conditions at supports
      // For pinned/roller supports, slope may not be zero, but we'll account for this
      const leftSupportIndex = supports.length > 0 ? 
        Math.round((Math.min(...supports.map(s => s.location)) / beamLength) * (numPoints - 1)) : 0;
      
      // Second integration: deflection (inches)
      const deflection = [0];
      for (let i = 1; i < numPoints; i++) {
        const dx_ft = x[i] - x[i-1];
        const dx_in = dx_ft * 12; // Convert to inches
        // Trapezoidal integration
        deflection.push(deflection[i-1] + (slope[i-1] + slope[i]) * dx_in / 2);
      }
      
      // Adjust deflection so it's zero at left support
      if (leftSupportIndex >= 0 && leftSupportIndex < deflection.length) {
        const deflectionOffset = deflection[leftSupportIndex];
        for (let i = 0; i < deflection.length; i++) {
          deflection[i] -= deflectionOffset;
        }
      }
      
      // Find maximum deflection (absolute value)
      const maxDeflection = Math.max(...deflection.map(Math.abs));
      
      // Use user-provided deflection limit (in inches)
      // Since we calculated deflection assuming EI = 1 kip-in¬≤,
      // actual deflection = calculated_deflection / actual_EI
      // So: actual_EI = calculated_deflection / actual_deflection
      // For required EI: EI_required = calculated_deflection / deflection_limit
      // Units: deflection is in inches, so EI will be in kip-in¬≤
      // Convert to lb-in¬≤: 1 kip = 1000 lb
      const EIRequired_kip_in2 = maxDeflection / deflectionLimit_in;
      const EIRequired_lb_in2 = EIRequired_kip_in2 * 1000;
      
      // Convert to (10^6) in¬≤-lb format for display
      const EIRequired = EIRequired_lb_in2 / 1000000;
      
      return { deflection: maxDeflection, EIRequired };
    }

    function displayResults(beamLength, pointLoads, distributedLoads, pointMoments, supports, Mu, Vu, EIRequired, x, V, M) {
      document.getElementById('results').style.display = 'block';

      let beamRep = 'Multi-Support Beam:\n';
      beamRep += 'A' + '‚îÄ'.repeat(Math.floor(beamLength * 2)) + 'B\n';
      
      supports.forEach(support => {
        const pos = Math.floor(support.location * 2);
        const supportSymbol = support.type === 'pinned' ? '‚ñ≤' : 
                             support.type === 'roller' ? '‚ñº' : '‚óÜ';
        beamRep += ' '.repeat(pos) + `${supportSymbol} ${support.type.charAt(0).toUpperCase() + support.type.slice(1)} Support\n`;
      });

      pointLoads.forEach(load => {
        const pos = Math.floor(load.location * 2);
        beamRep += ' '.repeat(pos) + `‚Üì Pu = ${(load.magnitude/1000).toFixed(2)} kips\n`;
      });

      distributedLoads.forEach(load => {
        const startPos = Math.floor(load.start * 2);
        const length = Math.floor((load.end - load.start) * 2);
        beamRep += ' '.repeat(startPos) + '‚ïê'.repeat(length) + ` w = ${(load.magnitude/1000).toFixed(2)} kips/ft\n`;
      });

      pointMoments.forEach(moment => {
        const pos = Math.floor(moment.location * 2);
        const momentSymbol = moment.magnitude > 0 ? '‚Üª' : '‚Ü∫';
        beamRep += ' '.repeat(pos) + `${momentSymbol} Mu = ${moment.magnitude.toFixed(2)} kip-ft\n`;
      });

      document.getElementById('beamRepresentation').textContent = beamRep;

      document.getElementById('momentValue').textContent = Mu.toFixed(2);
      document.getElementById('shearValue').textContent = Vu.toFixed(2);
      document.getElementById('eiValue').textContent = EIRequired.toFixed(2);

      const trace1 = {
        x: x,
        y: V,
        type: 'scatter',
        mode: 'lines',
        name: 'Shear Force',
        line: {
          color: '#00ff9f', /* Green for dark mode */
          width: 3
        },
        fill: 'tozeroy',
        fillcolor: 'rgba(0, 255, 159, 0.1)',
        hovertemplate: '<b>Shear Force</b><br>Position: %{x:.2f} ft<br>Shear: %{y:.2f} kips<extra></extra>'
      };

      const trace2 = {
        x: x,
        y: M,
        type: 'scatter',
        mode: 'lines',
        name: 'Bending Moment',
        line: {
          color: '#ff5555', /* Red for contrast */
          width: 3
        },
        fill: 'tozeroy',
        fillcolor: 'rgba(255, 85, 85, 0.1)',
        yaxis: 'y2',
        hovertemplate: '<b>Bending Moment</b><br>Position: %{x:.2f} ft<br>Moment: %{y:.2f} kip-ft<extra></extra>'
      };

      const layout = {
        title: {
          text: 'Beam Analysis - Shear Force and Bending Moment Diagrams',
          font: { size: 20, color: '#ecf0f1' } /* Light text */
        },
        xaxis: {
          title: { text: 'Position along beam (ft)', font: { size: 14, color: '#e0e0e0' } },
          gridcolor: '#444', /* Darker gridlines */
          zeroline: true,
          zerolinecolor: '#555',
          zerolinewidth: 2
        },
        yaxis: {
          title: { text: 'Shear Force (kips)', font: { size: 14, color: '#00ff9f' } },
          side: 'left',
          gridcolor: '#444',
          zeroline: true,
          zerolinecolor: '#555',
          zerolinewidth: 2
        },
        yaxis2: {
          title: { text: 'Bending Moment (kip-ft)', font: { size: 14, color: '#ff5555' } },
          side: 'right',
          overlaying: 'y',
          gridcolor: '#444',
          zeroline: true,
          zerolinecolor: '#555',
          zerolinewidth: 2
        },
        height: 700,
        plot_bgcolor: '#1e1e1e', /* Dark plot background */
        paper_bgcolor: '#1e1e1e', /* Dark paper background */
        font: { family: 'Consolas, monospace', color: '#e0e0e0' },
        legend: {
          x: 1,
          y: 1,
          bgcolor: 'rgba(37, 37, 37, 0.8)', /* Matches styles.css */
          bordercolor: '#333',
          borderwidth: 1
        },
        margin: { l: 60, r: 60, t: 60, b: 60 }
      };

      Plotly.newPlot('plotlyDiv', [trace1, trace2], layout, {
        responsive: true,
        displayModeBar: true,
        modeBarButtonsToRemove: ['select2d', 'lasso2d'],
        displaylogo: false
      });

      document.getElementById('results').scrollIntoView({ behavior: 'smooth' });
    }

    document.addEventListener('input', function(e) {
      if (e.target.classList.contains('table-input')) {
        const row = e.target.closest('tr');
        const hasValues = Array.from(row.querySelectorAll('input')).some(input => input.value !== '');
        
        if (hasValues) {
          row.classList.remove('empty-row');
        } else {
          row.classList.add('empty-row');
        }
      }
    });

    function updateDefaultValues() {
      const beamLength = parseFloat(document.getElementById('beamLength').value) || 20;
      const midLength = beamLength / 2;
      
      // Update point load location to midlength
      const pointLocationInput = document.getElementById('defaultPointLocation');
      if (pointLocationInput) {
        pointLocationInput.value = midLength.toFixed(1);
      }
      
      // Update distributed load to span full beam
      const distStartInput = document.getElementById('defaultDistStart');
      const distEndInput = document.getElementById('defaultDistEnd');
      if (distStartInput) {
        distStartInput.value = '0';
      }
      if (distEndInput) {
        distEndInput.value = beamLength.toFixed(1);
      }
      
      // Update deflection limit helper values
      const l360Value = (beamLength * 12) / 360;
      const l240Value = (beamLength * 12) / 240;
      const l180Value = (beamLength * 12) / 180;
      
      const l360Span = document.getElementById('l360Value');
      const l240Span = document.getElementById('l240Value');
      const l180Span = document.getElementById('l180Value');
      
      if (l360Span) l360Span.textContent = l360Value.toFixed(2);
      if (l240Span) l240Span.textContent = l240Value.toFixed(2);
      if (l180Span) l180Span.textContent = l180Value.toFixed(2);
      
      // Set default deflection limit to L/360 if empty
      const maxDeflectionInput = document.getElementById('maxDeflection');
      if (maxDeflectionInput && !maxDeflectionInput.value) {
        maxDeflectionInput.value = l360Value.toFixed(2);
      }
    }

    // Update defaults when beam length changes
    document.getElementById('beamLength').addEventListener('input', updateDefaultValues);

    window.onload = function() {
      updateDefaultValues();
      analyzeBeam();
    };
  </script>
</body>
</html>