<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Structural Terminal</title>
  <style>
    /* Basic “dark terminal” styling – adjust to taste */
    body {
      margin: 0;
      padding: 0;
      font-family: Menlo, Consolas, Monaco, monospace;
      background-color: #1e1e1e;
      color: #ffffff;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

    #terminalOutput {
      flex: 1;
      padding: 12px;
      overflow-y: auto;
      border-bottom: 1px solid #333;
    }

    #terminalInput {
      padding: 8px 12px;
      font-size: 14px;
      background-color: #252526;
      color: #c5c5c5;
      border: none;
      border-top: 1px solid #333;
      outline: none;
    }

    #terminalInput:disabled {
      color: #555;
      background-color: #2d2d2d;
    }

    .prompt-line {
      display: flex;
      align-items: center;
    }

    .prompt-line > span.prompt-symbol {
      margin-right: 6px;
      color: #00ff00; /* green “>” */
    }

    .output-line {
      white-space: pre-wrap;
    }

    .loading {
      color: #cccccc;
    }

    .error {
      color: #f44747; /* red */
    }
  </style>
</head>
<body>

  <!-- Input field: disabled until both JSONs load -->
  <input
    type="text"
    id="terminalInput"
    placeholder="(Loading…)"
    disabled
    autocomplete="off"
  />

  <!-- Output area -->
  <div id="terminalOutput">
    <!-- Initial “loading” message: -->
    <div class="prompt-line loading">
      <span class="prompt-symbol">&gt;</span>
      <span>Loading data…</span>
    </div>
  </div>

  <!-- All JavaScript lives here -->
  <script>
    // ------------------------------------------------------------------------
    // 1) Variables to hold loaded JSON data and “loaded” flags:
    // ------------------------------------------------------------------------
    let wShapeData = null;
    let mcShapeData = null;
    let wShapeLoaded = false;
    let mcShapeLoaded = false;

    // Variables for Lr calculation state
    let lrState = null;       // null | "awaitingFy" | "awaitingC"
    let lrShapeObj = null;
    const lrE = 29000;        // default E (ksi)
    let lrFy = null;

    // ------------------------------------------------------------------------
    // 2) Utility: print a new line of text into #terminalOutput
    //    - argument `text` can be a string (plain text) or
    //      an HTML‐formatted string if you want color, etc.
    // ------------------------------------------------------------------------
    function printLine(text, cssClass = "output-line") {
      const outDiv = document.getElementById("terminalOutput");
      const line = document.createElement("div");
      line.className = cssClass;
      line.innerText = text;
      outDiv.appendChild(line);

      // Scroll to bottom whenever a new line is printed
      outDiv.scrollTop = outDiv.scrollHeight;
    }

    // ------------------------------------------------------------------------
    // 3) After BOTH JSONs have loaded, enable the input:
    // ------------------------------------------------------------------------
    function tryEnableInput() {
      if (wShapeLoaded && mcShapeLoaded) {
        const input = document.getElementById("terminalInput");
        input.disabled = false;
        input.placeholder = "Search a shape (e.g. W12X16)…";
        input.focus();

        // Remove the initial “Loading data…” line:
        document.getElementById("terminalOutput").innerHTML = "";
        // Print a welcome message now that data is available:
        printLine("> Data loaded. Type a shape name and press Enter.");
      }
    }

    // ------------------------------------------------------------------------
    // 4) Fetch W‐section JSON
    // ------------------------------------------------------------------------
    fetch("js/w-member-data.json")
      .then((resp) => {
        if (!resp.ok) throw new Error(`W JSON HTTP ${resp.status}`);
        return resp.json();
      })
      .then((json) => {
        wShapeData = json;
        wShapeLoaded = true;
        tryEnableInput();
      })
      .catch((err) => {
        console.error("❌ Error loading W JSON:", err);
        // Show an error on screen:
        document.getElementById("terminalOutput").innerHTML = "";
        printLine("Error: Could not load W‐member JSON.", "error");
      });

    // ------------------------------------------------------------------------
    // 5) Fetch MC‐section JSON
    // ------------------------------------------------------------------------
    fetch("js/mc-member-data.json")
      .then((resp) => {
        if (!resp.ok) throw new Error(`MC JSON HTTP ${resp.status}`);
        return resp.json();
      })
      .then((json) => {
        mcShapeData = json;
        mcShapeLoaded = true;
        tryEnableInput();
      })
      .catch((err) => {
        console.error("❌ Error loading MC JSON:", err);
        document.getElementById("terminalOutput").innerHTML = "";
        printLine("Error: Could not load MC‐member JSON.", "error");
      });

    // ------------------------------------------------------------------------
    // 6) Handle “Enter” key presses in the input
    //    - When user types e.g. “W12X16” and presses Enter, look it up.
    //    - If found in wShapeData, print the full JSON object for that shape.
    //    - Otherwise, check mcShapeData for a matching key.
    //    - If still not found, print “Not found.”
    // ------------------------------------------------------------------------
    document
      .getElementById("terminalInput")
      .addEventListener("keydown", function (evt) {
        if (evt.key === "Enter") {
          const rawValue = this.value.trim().toUpperCase();
          this.value = ""; // clear input
          if (!rawValue) return;

          // Print the prompt line with the user’s request
          printLine(`> ${rawValue}`, "prompt-line");

          // ----- Lr state machine -----
          // If we’re waiting for Fy, parse it now:
          if (lrState === "awaitingFy") {
            const fyVal = parseFloat(rawValue);
            if (isNaN(fyVal) || fyVal <= 0) {
              printLine("❌ Please enter a valid numeric Fy.", "error");
              return;
            }
            lrFy = fyVal;
            lrState = "awaitingC";
            printLine("Enter c (conservative):");
            return;
          }

          // If we’re waiting for c, parse it and compute Lr:
          if (lrState === "awaitingC") {
            const cVal = parseFloat(rawValue);
            if (isNaN(cVal) || cVal <= 0) {
              printLine("❌ Please enter a valid numeric c.", "error");
              return;
            }
            // Compute Lr using formula:
            const shapeObj = lrShapeObj;
            const d = parseFloat(shapeObj["d"]);
            const tf = parseFloat(shapeObj["tf"]);
            const ho = d - tf;
            const Sx = parseFloat(shapeObj["Sx"]);
            const J = parseFloat(shapeObj["J"]);
            const Jc = J * cVal;
            const r_ts = Math.sqrt(Jc / (Sx * ho));
            const term = (0.7 * lrFy / lrE) * (Sx * ho) / Jc;
            const inside = 1 + Math.sqrt(1 + 6.76 * Math.pow(term, 2));
            const Lr = 1.95 * r_ts * Math.sqrt(lrE / (0.7 * lrFy)) * Math.sqrt(inside);
            printLine(`Lr = ${Lr.toFixed(2)} in (for Fy=${lrFy}, c=${cVal})`);
            lrState = null;
            lrShapeObj = null;
            return;
          }
          // ----- End Lr state machine -----

          // Detect “<W##X##> LR” command to start Lr flow:
          const lrMatch = rawValue.match(/^(W\d+X\d+)\s+LR$/i);
          if (lrMatch && wShapeData) {
            const wk = lrMatch[1];
            if (!wShapeData[wk]) {
              printLine(`❌ Shape not found: ${wk}`, "error");
              return;
            }
            // Initialize Lr sequence
            lrShapeObj = wShapeData[wk];
            lrState = "awaitingFy";
            printLine(`E (ksi) default = ${lrE}`);
            printLine("Enter Fy (ksi):");
            return;
          }

          // First, check W shapes:
          if (wShapeData && wShapeData[rawValue]) {
            const shapeObj = wShapeData[rawValue];
            // Print each key/value pair as “key<TAB>value”
            Object.entries(shapeObj).forEach(([key, val]) => {
              printLine(`${key}\t${val}`);
            });
            // Add a Copy to Excel button
            const btn = document.createElement("button");
            btn.textContent = "Copy to Excel";
            btn.onclick = () => copyLastShapeToClipboard(shapeObj);
            const outDiv = document.getElementById("terminalOutput");
            outDiv.appendChild(btn);
            return;
          }

          // Next, check MC shapes:
          if (mcShapeData && mcShapeData[rawValue]) {
            const shapeObj = mcShapeData[rawValue];
            // Print each key/value pair as “key<TAB>value”
            Object.entries(shapeObj).forEach(([key, val]) => {
              printLine(`${key}\t${val}`);
            });
            // Add a Copy to Excel button
            const btn = document.createElement("button");
            btn.textContent = "Copy to Excel";
            btn.onclick = () => copyLastShapeToClipboard(shapeObj);
            const outDiv = document.getElementById("terminalOutput");
            outDiv.appendChild(btn);
            return;
          }

          // If not found in either:
          printLine(`Shape “${rawValue}” not found.`, "error");
        }
      });

    // ------------------------------------------------------------------------
    // 8) Copy-to-clipboard for last printed shape
    //    Creates tab-separated lines “key<TAB>value” for Excel.
    // ------------------------------------------------------------------------
    function copyLastShapeToClipboard(shapeObj) {
      const lines = Object.entries(shapeObj).map(
        ([key, val]) => `${key}\t${val}`
      );
      const text = lines.join("\n");
      // Create a temporary textarea to copy from
      const textarea = document.createElement("textarea");
      textarea.value = text;
      document.body.appendChild(textarea);
      textarea.select();
      document.execCommand("copy");
      document.body.removeChild(textarea);
      // Optional feedback
      printLine("(Copied to clipboard)", "loading");
    }

    // ------------------------------------------------------------------------
    // 7) Show suggestions as user types (optional enhancement)
    // ------------------------------------------------------------------------
    const suggestionsDiv = document.createElement("div");
    suggestionsDiv.style.position = "absolute";
    suggestionsDiv.style.backgroundColor = "#252526";
    suggestionsDiv.style.color = "#c5c5c5";
    suggestionsDiv.style.border = "1px solid #333";
    suggestionsDiv.style.maxHeight = "150px";
    suggestionsDiv.style.overflowY = "auto";
    suggestionsDiv.style.width = "200px";
    suggestionsDiv.style.display = "none";
    suggestionsDiv.style.zIndex = "1000";
    document.body.appendChild(suggestionsDiv);

    const inputElem = document.getElementById("terminalInput");
    inputElem.style.position = "relative";

    inputElem.addEventListener("input", () => {
      const rect = inputElem.getBoundingClientRect();
      suggestionsDiv.style.top = rect.bottom + window.scrollY + "px";
      suggestionsDiv.style.left = rect.left + window.scrollX + "px";
      showSuggestions(inputElem.value);
    });

    function showSuggestions(inputValue) {
        if ((!wShapeLoaded && !mcShapeLoaded) || !inputValue) {
          suggestionsDiv.style.display = 'none';
          return;
        }
        // Combine keys from both data sets
        const allKeys = Object.keys(wShapeData).concat(Object.keys(mcShapeData));
        const matches = allKeys.filter(key =>
          key.startsWith(inputValue.toUpperCase())
        );
        // Sort: For W-shapes, extract weight (second number) and sort ascending by weight.
        // For non-W keys, fallback to sorting by the first numeric sequence.
        matches.sort((a, b) => {
          const wA = a.match(/^W(\d+)X(\d+)/i);
          const wB = b.match(/^W(\d+)X(\d+)/i);
          if (wA && wB) {
            const weightA = parseInt(wA[2], 10);
            const weightB = parseInt(wB[2], 10);
            return weightA - weightB;
          }
          // If only one is a W-shape, prefer that first
          if (wA && !wB) return -1;
          if (!wA && wB) return 1;
          // Otherwise, fallback to first numeric sequence
          const numA = parseInt(a.match(/\d+/)[0], 10);
          const numB = parseInt(b.match(/\d+/)[0], 10);
          return numA - numB;
        });

        if (matches.length) {
          suggestionsDiv.innerHTML = matches
            .map(key => `<div style="padding:4px; cursor:pointer;">${key}</div>`)
            .join("");
          suggestionsDiv.style.display = "block";

          // Add click handlers to suggestions
          Array.from(suggestionsDiv.children).forEach((child, idx) => {
            child.addEventListener("click", () => {
              inputElem.value = matches[idx];
              suggestionsDiv.style.display = "none";
              inputElem.focus();
            });
          });
        } else {
          suggestionsDiv.style.display = "none";
        }
    }
  </script>
</body>
</html>