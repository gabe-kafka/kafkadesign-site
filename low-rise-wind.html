<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Structural Analysis - Kafka Design</title>
  <link rel="stylesheet" href="css/styles.css">
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <style>
    * {
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      margin: 0;
      padding: 20px;
      min-height: 100vh;
    }
    
    .container {
      max-width: 1200px;
      margin: 0 auto;
      background: white;
      border-radius: 15px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.2);
      overflow: hidden;
    }
    
    .header {
      background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
      color: white;
      padding: 30px;
      text-align: center;
    }
    
    .header h1 {
      margin: 0;
      font-size: 2.5em;
      font-weight: 300;
    }
    
    .header p {
      margin: 10px 0 0 0;
      opacity: 0.9;
      font-size: 1.1em;
    }
    
    .content {
      padding: 30px;
    }
    
    .input-section {
      margin-bottom: 30px;
    }
    
    .input-group {
      margin: 20px 0;
    }
    
    .input-group label {
      display: block;
      margin-bottom: 8px;
      font-weight: 600;
      color: #2c3e50;
      font-size: 1.1em;
    }
    
    .input-group input {
      width: 200px;
      padding: 12px;
      border: 2px solid #e0e0e0;
      border-radius: 8px;
      font-size: 16px;
      transition: border-color 0.3s;
    }
    
    .input-group input:focus {
      outline: none;
      border-color: #667eea;
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
    }
    
    .spreadsheet-container {
      margin: 25px 0;
      border-radius: 10px;
      overflow: hidden;
      box-shadow: 0 4px 15px rgba(0,0,0,0.1);
    }
    
    .spreadsheet-title {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 15px 20px;
      margin: 0;
      font-size: 1.3em;
      font-weight: 600;
    }
    
    .table-container {
      overflow-x: auto;
      background: white;
    }
    
    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 14px;
    }
    
    th {
      background: #f8f9fa;
      padding: 15px 12px;
      text-align: left;
      font-weight: 600;
      color: #2c3e50;
      border-bottom: 2px solid #e9ecef;
    }
    
    td {
      padding: 12px;
      border-bottom: 1px solid #e9ecef;
      vertical-align: middle;
    }
    
    tr:hover {
      background-color: #f8f9fa;
    }
    
    .table-input {
      width: 100%;
      padding: 8px 12px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 14px;
      transition: border-color 0.3s;
    }
    
    .table-input:focus {
      outline: none;
      border-color: #667eea;
      box-shadow: 0 0 0 2px rgba(102, 126, 234, 0.1);
    }
    
    .btn {
      padding: 8px 12px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 500;
      transition: all 0.3s;
    }
    
    .btn-add {
      background: #28a745;
      color: white;
      margin: 15px 0;
      padding: 10px 20px;
      font-size: 14px;
    }
    
    .btn-add:hover {
      background: #218838;
      transform: translateY(-1px);
    }
    
    .btn-remove {
      background: #dc3545;
      color: white;
    }
    
    .btn-remove:hover {
      background: #c82333;
    }
    
    .btn-analyze {
      background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
      color: white;
      padding: 15px 40px;
      font-size: 18px;
      font-weight: 600;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      margin: 30px 0;
      transition: all 0.3s;
      box-shadow: 0 4px 15px rgba(40, 167, 69, 0.3);
    }
    
    .btn-analyze:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(40, 167, 69, 0.4);
    }
    
    .results {
      margin-top: 30px;
      padding: 25px;
      background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
      border-radius: 15px;
      box-shadow: inset 0 2px 10px rgba(0,0,0,0.1);
    }
    
    .results h3 {
      color: #2c3e50;
      margin-top: 0;
      font-size: 1.5em;
      font-weight: 600;
    }
    
    .beam-diagram {
      margin: 20px 0;
      font-family: 'Courier New', monospace;
      background: #2c3e50;
      color: #ecf0f1;
      padding: 20px;
      border-radius: 10px;
      font-size: 14px;
      line-height: 1.4;
      overflow-x: auto;
    }
    
    .calculation-results {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      margin: 20px 0;
    }
    
    .result-card {
      background: white;
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      text-align: center;
    }
    
    .result-value {
      font-size: 2em;
      font-weight: bold;
      color: #667eea;
      margin: 10px 0;
    }
    
    .result-label {
      color: #6c757d;
      font-size: 0.9em;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    
    #plotlyDiv {
      width: 100%;
      height: 700px;
      margin-top: 25px;
      border-radius: 10px;
      overflow: hidden;
      box-shadow: 0 4px 20px rgba(0,0,0,0.1);
    }
    
    .back-link {
      display: inline-block;
      margin-top: 30px;
      padding: 12px 24px;
      background: #6c757d;
      color: white;
      text-decoration: none;
      border-radius: 8px;
      transition: all 0.3s;
    }
    
    .back-link:hover {
      background: #5a6268;
      transform: translateY(-1px);
    }

    .empty-row {
      opacity: 0.6;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>Structural Beam Analysis</h1>
      <p>Advanced analysis of beams with multiple supports and interactive visualization</p>
    </div>
    
    <div class="content">
      <div class="input-section">
        <div class="input-group">
          <label for="beamLength">Beam Length (ft):</label>
          <input type="number" id="beamLength" value="20" step="0.1" min="0.1">
        </div>
      </div>

      <div class="spreadsheet-container">
        <h3 class="spreadsheet-title">Point Loads</h3>
        <div class="table-container">
          <table id="pointLoadsTable">
            <thead>
              <tr>
                <th>Location (ft)</th>
                <th>Load (kips)</th>
                <th>Action</th>
              </tr>
            </thead>
            <tbody id="pointLoadsBody">
              <tr>
                <td><input type="number" class="table-input point-location" value="10" step="0.1" min="0"></td>
                <td><input type="number" class="table-input point-magnitude" value="5" step="0.1"></td>
                <td><button class="btn btn-remove" onclick="removeRow(this)">Remove</button></td>
              </tr>
              <tr class="empty-row">
                <td><input type="number" class="table-input point-location" value="" step="0.1" min="0" placeholder="Enter location"></td>
                <td><input type="number" class="table-input point-magnitude" value="" step="0.1" placeholder="Enter load"></td>
                <td><button class="btn btn-remove" onclick="removeRow(this)">Remove</button></td>
              </tr>
            </tbody>
          </table>
        </div>
        <button class="btn btn-add" onclick="addPointLoad()">+ Add Point Load</button>
      </div>

      <div class="spreadsheet-container">
        <h3 class="spreadsheet-title">Distributed Loads</h3>
        <div class="table-container">
          <table id="distributedLoadsTable">
            <thead>
              <tr>
                <th>Start (ft)</th>
                <th>End (ft)</th>
                <th>Load (kips/ft)</th>
                <th>Action</th>
              </tr>
            </thead>
            <tbody id="distributedLoadsBody">
              <tr>
                <td><input type="number" class="table-input dist-start" value="2" step="0.1" min="0"></td>
                <td><input type="number" class="table-input dist-end" value="8" step="0.1" min="0"></td>
                <td><input type="number" class="table-input dist-magnitude" value="1" step="0.1"></td>
                <td><button class="btn btn-remove" onclick="removeRow(this)">Remove</button></td>
              </tr>
              <tr class="empty-row">
                <td><input type="number" class="table-input dist-start" value="" step="0.1" min="0" placeholder="Start"></td>
                <td><input type="number" class="table-input dist-end" value="" step="0.1" min="0" placeholder="End"></td>
                <td><input type="number" class="table-input dist-magnitude" value="" step="0.1" placeholder="Load"></td>
                <td><button class="btn btn-remove" onclick="removeRow(this)">Remove</button></td>
              </tr>
            </tbody>
          </table>
        </div>
        <button class="btn btn-add" onclick="addDistributedLoad()">+ Add Distributed Load</button>
      </div>

      <div class="spreadsheet-container">
        <h3 class="spreadsheet-title">Support Locations</h3>
        <div class="table-container">
          <table id="supportsTable">
            <thead>
              <tr>
                <th>Location (ft)</th>
                <th>Support Type</th>
                <th>Action</th>
              </tr>
            </thead>
            <tbody id="supportsBody">
              <tr>
                <td><input type="number" class="table-input support-location" value="0" step="0.1" min="0"></td>
                <td>
                  <select class="table-input support-type">
                    <option value="pinned" selected>Pinned</option>
                    <option value="roller">Roller</option>
                    <option value="fixed">Fixed</option>
                  </select>
                </td>
                <td><button class="btn btn-remove" onclick="removeRow(this)">Remove</button></td>
              </tr>
              <tr>
                <td><input type="number" class="table-input support-location" value="20" step="0.1" min="0"></td>
                <td>
                  <select class="table-input support-type">
                    <option value="pinned">Pinned</option>
                    <option value="roller" selected>Roller</option>
                    <option value="fixed">Fixed</option>
                  </select>
                </td>
                <td><button class="btn btn-remove" onclick="removeRow(this)">Remove</button></td>
              </tr>
              <tr class="empty-row">
                <td><input type="number" class="table-input support-location" value="" step="0.1" min="0" placeholder="Enter location"></td>
                <td>
                  <select class="table-input support-type">
                    <option value="pinned">Pinned</option>
                    <option value="roller">Roller</option>
                    <option value="fixed">Fixed</option>
                  </select>
                </td>
                <td><button class="btn btn-remove" onclick="removeRow(this)">Remove</button></td>
              </tr>
            </tbody>
          </table>
        </div>
        <button class="btn btn-add" onclick="addSupport()">+ Add Support</button>
        <p style="margin-top: 10px; font-size: 0.9em; color: #666;">
          <strong>Note:</strong> For statically determinate beams, you need exactly one pinned support and one roller support. 
          For indeterminate beams, you can add more supports.
        </p>
      </div>

      <div style="text-align: center;">
        <button class="btn-analyze" onclick="analyzeBeam()">üîç Analyze Beam</button>
      </div>

      <div id="results" class="results" style="display: none;">
        <h3>Analysis Results</h3>
        <div id="beamRepresentation" class="beam-diagram"></div>
        <div class="calculation-results">
          <div class="result-card">
            <div class="result-label">Ultimate Moment</div>
            <div class="result-value" id="momentValue">0.00</div>
            <div>kip-ft</div>
          </div>
          <div class="result-card">
            <div class="result-label">Ultimate Shear</div>
            <div class="result-value" id="shearValue">0.00</div>
            <div>kips</div>
          </div>
        </div>
        <div id="plotlyDiv"></div>
      </div>

      <a href="index.html" class="back-link">‚Üê Back to Home</a>
    </div>
  </div>

  <script>
    function addPointLoad() {
      const tbody = document.getElementById('pointLoadsBody');
      const newRow = document.createElement('tr');
      newRow.innerHTML = `
        <td><input type="number" class="table-input point-location" value="" step="0.1" min="0" placeholder="Enter location"></td>
        <td><input type="number" class="table-input point-magnitude" value="" step="0.1" placeholder="Enter load"></td>
        <td><button class="btn btn-remove" onclick="removeRow(this)">Remove</button></td>
      `;
      tbody.appendChild(newRow);
    }

    function addDistributedLoad() {
      const tbody = document.getElementById('distributedLoadsBody');
      const newRow = document.createElement('tr');
      newRow.innerHTML = `
        <td><input type="number" class="table-input dist-start" value="" step="0.1" min="0" placeholder="Start"></td>
        <td><input type="number" class="table-input dist-end" value="" step="0.1" min="0" placeholder="End"></td>
        <td><input type="number" class="table-input dist-magnitude" value="" step="0.1" placeholder="Load"></td>
        <td><button class="btn btn-remove" onclick="removeRow(this)">Remove</button></td>
      `;
      tbody.appendChild(newRow);
    }

    function addSupport() {
      const tbody = document.getElementById('supportsBody');
      const newRow = document.createElement('tr');
      newRow.innerHTML = `
        <td><input type="number" class="table-input support-location" value="" step="0.1" min="0" placeholder="Enter location"></td>
        <td>
          <select class="table-input support-type">
            <option value="pinned">Pinned</option>
            <option value="roller">Roller</option>
            <option value="fixed">Fixed</option>
          </select>
        </td>
        <td><button class="btn btn-remove" onclick="removeRow(this)">Remove</button></td>
      `;
      tbody.appendChild(newRow);
    }

    function removeRow(button) {
      const row = button.closest('tr');
      const tbody = row.parentNode;
      
      // Don't remove if it's the last row in the table
      if (tbody.children.length > 1) {
        row.remove();
      } else {
        // Clear the inputs instead
        row.querySelectorAll('input').forEach(input => input.value = '');
      }
    }

    function analyzeBeam() {
      // Get input values
      const beamLength = parseFloat(document.getElementById('beamLength').value);
      
      // Get point loads from table
      const pointLoads = [];
      document.querySelectorAll('#pointLoadsBody tr').forEach(row => {
        const location = parseFloat(row.querySelector('.point-location').value);
        const magnitude = parseFloat(row.querySelector('.point-magnitude').value);
        if (!isNaN(location) && !isNaN(magnitude) && location <= beamLength && magnitude !== 0) {
          pointLoads.push({location, magnitude: magnitude * 1000}); // Convert to pounds
        }
      });

      // Get distributed loads from table
      const distributedLoads = [];
      document.querySelectorAll('#distributedLoadsBody tr').forEach(row => {
        const start = parseFloat(row.querySelector('.dist-start').value);
        const end = parseFloat(row.querySelector('.dist-end').value);
        const magnitude = parseFloat(row.querySelector('.dist-magnitude').value);
        if (!isNaN(start) && !isNaN(end) && !isNaN(magnitude) && start < end && end <= beamLength && magnitude !== 0) {
          distributedLoads.push({start, end, magnitude: magnitude * 1000}); // Convert to pounds/ft
        }
      });

      // Get supports from table (assuming supports are added here)
      const supports = [];
      document.querySelectorAll('#supportsBody tr').forEach(row => {
        const location = parseFloat(row.querySelector('.support-location').value);
        const type = row.querySelector('.support-type').value;
        if (!isNaN(location) && type) {
          supports.push({location, type});
        }
      });

      // Sort loads
      pointLoads.sort((a, b) => a.location - b.location);
      distributedLoads.sort((a, b) => a.start - b.start);
      supports.sort((a, b) => a.location - b.location);

      // Validate supports
      if (supports.length < 2) {
        alert('At least 2 supports are required for a stable beam.');
        return;
      }

      // Check if beam is statically determinate
      const pinnedSupports = supports.filter(s => s.type === 'pinned').length;
      const rollerSupports = supports.filter(s => s.type === 'roller').length;
      const fixedSupports = supports.filter(s => s.type === 'fixed').length;
      
      const isDeterminate = (pinnedSupports === 1 && rollerSupports === 1 && fixedSupports === 0) ||
                           (pinnedSupports === 0 && rollerSupports === 2 && fixedSupports === 0);

      if (!isDeterminate && supports.length === 2) {
        alert('For 2 supports, you need either 1 pinned + 1 roller, or 2 rollers for a statically determinate beam.');
        return;
      }

      // Calculate reactions based on support configuration
      let reactions = [];
      
      if (isDeterminate) {
        // Simple statically determinate analysis
        reactions = calculateDeterminateReactions(beamLength, supports, pointLoads, distributedLoads);
      } else {
        // Statically indeterminate analysis using force method
        reactions = calculateIndeterminateReactions(beamLength, supports, pointLoads, distributedLoads);
      }

      // Calculate internal forces
      const { V, M, x } = calculateInternalForces(beamLength, supports, reactions, pointLoads, distributedLoads);

      const Vu = Math.max(...V.map(Math.abs));
      const Mu = Math.max(...M.map(Math.abs));

      // Display results
      displayResults(beamLength, pointLoads, distributedLoads, supports, Mu, Vu, x, V, M);
    }

    function calculateDeterminateReactions(beamLength, supports, pointLoads, distributedLoads) {
      // For determinate beams, use equilibrium equations
      const reactions = new Array(supports.length).fill(0);
      
      if (supports.length === 2) {
        // Traditional simply supported beam analysis
        let R_left = 0, R_right = 0;

        // Point load contributions
        pointLoads.forEach(load => {
          R_left += load.magnitude * (beamLength - load.location) / beamLength;
          R_right += load.magnitude * load.location / beamLength;
        });

        // Distributed load contributions
        distributedLoads.forEach(load => {
          const length = load.end - load.start;
          const centroid = (load.start + load.end) / 2;
          const totalLoad = load.magnitude * length;
          R_left += totalLoad * (beamLength - centroid) / beamLength;
          R_right += totalLoad * centroid / beamLength;
        });

        reactions[0] = R_left / 1000; // Convert to kips
        reactions[1] = R_right / 1000;
      }
      
      return reactions;
    }

    function calculateIndeterminateReactions(beamLength, supports, pointLoads, distributedLoads) {
      // For indeterminate beams, use simplified approach
      // This is a simplified version - in practice, you'd use matrix analysis
      const reactions = new Array(supports.length).fill(0);
      
      // Calculate total load
      let totalLoad = 0;
      pointLoads.forEach(load => totalLoad += load.magnitude);
      distributedLoads.forEach(load => {
        totalLoad += load.magnitude * (load.end - load.start);
      });

      // Distribute load equally among supports (simplified)
      const loadPerSupport = totalLoad / supports.length;
      reactions.fill(loadPerSupport / 1000); // Convert to kips
      
      return reactions;
    }

    function calculateInternalForces(beamLength, supports, reactions, pointLoads, distributedLoads) {
      const numPoints = 1000;
      const x = [];
      const V = [];
      const M = [];

      for (let i = 0; i < numPoints; i++) {
        const x_val = (i / (numPoints - 1)) * beamLength;
        x.push(x_val);

        // Calculate shear at this point
        let V_val = 0;
        
        // Add reaction forces
        supports.forEach((support, index) => {
          if (x_val >= support.location) {
            V_val += reactions[index];
          }
        });

        // Subtract point loads to the left
        pointLoads.forEach(load => {
          if (x_val > load.location) {
            V_val -= load.magnitude / 1000;
          }
        });

        // Subtract distributed loads
        distributedLoads.forEach(load => {
          if (x_val >= load.start && x_val <= load.end) {
            V_val -= (load.magnitude * (x_val - load.start)) / 1000;
          } else if (x_val > load.end) {
            V_val -= (load.magnitude * (load.end - load.start)) / 1000;
          }
        });

        V.push(V_val);
      }

      // Calculate moment by integrating shear force using trapezoidal rule
      M[0] = 0; // Start with zero moment
      for (let i = 1; i < numPoints; i++) {
        const dx = x[i] - x[i-1];
        // M[i] = M[i-1] + area under shear curve from x[i-1] to x[i]
        // Area = average shear * dx = (V[i-1] + V[i]) * dx / 2
        M[i] = M[i-1] + (V[i-1] + V[i]) * dx / 2;
      }

      // Adjust moment to ensure it's zero at the leftmost support (for simply supported beams)
      if (supports.length >= 2) {
        const leftSupport = Math.min(...supports.map(s => s.location));
        const leftIndex = Math.round((leftSupport / beamLength) * (numPoints - 1));
        
        if (leftIndex >= 0 && leftIndex < M.length) {
          const leftMoment = M[leftIndex];
          for (let i = 0; i < M.length; i++) {
            M[i] -= leftMoment;
          }
        }
      }

      return { V, M, x };
    }

    function displayResults(beamLength, pointLoads, distributedLoads, supports, Mu, Vu, x, V, M) {
      // Show results section
      document.getElementById('results').style.display = 'block';

      // Create beam representation
      let beamRep = 'Multi-Support Beam:\n';
      beamRep += 'A' + '‚îÄ'.repeat(Math.floor(beamLength * 2)) + 'B\n';
      
      // Show supports
      supports.forEach(support => {
        const pos = Math.floor(support.location * 2);
        const supportSymbol = support.type === 'pinned' ? '‚ñ≤' : 
                             support.type === 'roller' ? '‚ñº' : '‚óÜ';
        beamRep += ' '.repeat(pos) + `${supportSymbol} ${support.type.charAt(0).toUpperCase() + support.type.slice(1)} Support\n`;
      });

      pointLoads.forEach(load => {
        const pos = Math.floor(load.location * 2);
        beamRep += ' '.repeat(pos) + `‚Üì Pu = ${(load.magnitude/1000).toFixed(2)} kips\n`;
      });

      distributedLoads.forEach(load => {
        const startPos = Math.floor(load.start * 2);
        const length = Math.floor((load.end - load.start) * 2);
        beamRep += ' '.repeat(startPos) + '‚ïê'.repeat(length) + ` w = ${(load.magnitude/1000).toFixed(2)} kips/ft\n`;
      });

      document.getElementById('beamRepresentation').textContent = beamRep;

      // Display calculation results in cards
      document.getElementById('momentValue').textContent = Mu.toFixed(2);
      document.getElementById('shearValue').textContent = Vu.toFixed(2);

      // Create enhanced Plotly diagram
      const trace1 = {
        x: x,
        y: V,
        type: 'scatter',
        mode: 'lines',
        name: 'Shear Force',
        line: {
          color: '#3498db',
          width: 3
        },
        fill: 'tozeroy',
        fillcolor: 'rgba(52, 152, 219, 0.1)',
        hovertemplate: '<b>Shear Force</b><br>Position: %{x:.2f} ft<br>Shear: %{y:.2f} kips<extra></extra>'
      };

      const trace2 = {
        x: x,
        y: M,
        type: 'scatter',
        mode: 'lines',
        name: 'Bending Moment',
        line: {
          color: '#e74c3c',
          width: 3
        },
        fill: 'tozeroy',
        fillcolor: 'rgba(231, 76, 60, 0.1)',
        yaxis: 'y2',
        hovertemplate: '<b>Bending Moment</b><br>Position: %{x:.2f} ft<br>Moment: %{y:.2f} kip-ft<extra></extra>'
      };

      const layout = {
        title: {
          text: 'Beam Analysis - Shear Force and Bending Moment Diagrams',
          font: { size: 20, color: '#2c3e50' }
        },
        xaxis: {
          title: { text: 'Position along beam (ft)', font: { size: 14 } },
          gridcolor: '#ecf0f1',
          zeroline: true,
          zerolinecolor: '#bdc3c7',
          zerolinewidth: 2
        },
        yaxis: {
          title: { text: 'Shear Force (kips)', font: { size: 14, color: '#3498db' } },
          side: 'left',
          gridcolor: '#ecf0f1',
          zeroline: true,
          zerolinecolor: '#bdc3c7',
          zerolinewidth: 2
        },
        yaxis2: {
          title: { text: 'Bending Moment (kip-ft)', font: { size: 14, color: '#e74c3c' } },
          side: 'right',
          overlaying: 'y',
          gridcolor: '#ecf0f1',
          zeroline: true,
          zerolinecolor: '#bdc3c7',
          zerolinewidth: 2
        },
        height: 700,
        plot_bgcolor: 'white',
        paper_bgcolor: 'white',
        font: { family: 'Segoe UI, sans-serif' },
        legend: {
          x: 1,
          y: 1,
          bgcolor: 'rgba(255,255,255,0.8)',
          bordercolor: '#bdc3c7',
          borderwidth: 1
        },
        margin: { l: 60, r: 60, t: 60, b: 60 }
      };

      Plotly.newPlot('plotlyDiv', [trace1, trace2], layout, {
        responsive: true,
        displayModeBar: true,
        modeBarButtonsToRemove: ['select2d', 'lasso2d'],
        displaylogo: false
      });

      // Scroll to results
      document.getElementById('results').scrollIntoView({ behavior: 'smooth' });
    }

    // Add input event listeners for real-time validation
    document.addEventListener('input', function(e) {
      if (e.target.classList.contains('table-input')) {
        const row = e.target.closest('tr');
        const hasValues = Array.from(row.querySelectorAll('input')).some(input => input.value !== '');
        
        if (hasValues) {
          row.classList.remove('empty-row');
        } else {
          row.classList.add('empty-row');
        }
      }
    });

    // Run initial analysis with default values
    window.onload = function() {
      analyzeBeam();
    };
  </script>
</body>
</html> 